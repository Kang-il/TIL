#include <iostream>

// row -- > 이친수의 자릿수
// col -- > 마지막 자리에 오는 수 0,1
// 마지막자리에 0 , 1 이 오는 두 가지 경우를 따져서 이를 더해주면 답을 구할 수 있다.
long long D[91][2];
long long DP[91];
int main(){
    // ((2193))
    // 이친수 0과 1로만 이루어진 수를 이친수라고 한다.
    // 다음 조건을 만족하면 이친수 라고 한다.
    // 1. 이친수는 0으로 시작하지 않는다.
    // 2. 이친수에서는 1이 두번 연속으로 나타나지 않는다. 즉 11을 부분 문자열로 갖지 않는다.
    // N자리의 이친수의 갯수를 구하는 문제.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int N;
    std::cin>>N;

    D[1][1]=1;
    D[2][0]=1;
    //2차원 배열로 푸는 방법
    for(int i=3;i<=N;i++){
        //1. 마지막에 0이 온다면 그 전에 0과 1이 모두 올 수 있다.
        D[i][0]=D[i-1][0]+D[i-1][1];
        //2. 마지막에 1이 온다면 그 전엔 0밖에 올 수 없다.
        D[i][1]=D[i-1][0];
    }
    // 마지막에 0이 오는 경우의 수와 1이 오는 경우의 수를 모두 더한 값이 정답이 된다.
    long long sum = D[N][0]+D[N][1];
    std::cout<< sum <<'\n';

    //1차원 배열로 푸는 방법;
    //D[N] -- N자리 이친수
    //N자리 이친수 마지막에 오는 수
    // 1. 0 -- 마지막에 0이 왔다면 그 전에 1,0 ---- D[N-1] -- 뭐가 오든 상관없이 뒤에 0만 붙여도 상관없다.
    // 2. 1 -- 마지막에 1이 왔다면 그 전에 0 밖에 없다 ---- D[N-2] -- D[N-1]과D[N]을 묶어서 보아도 무방하다.
    DP[1]=1;
    DP[2]=1;
    for(int i=3;i<=N;i++){
        DP[i]=DP[i-1]+DP[i-2];
    }

    std::cout<<DP[N]<<'\n';

    return 0;
}

